<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>VUE 常见面试整理 | 博客首页</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/Vimalate/resb.jpg">
    <meta name="description" content="Vimalakirti的前端记录">
    <meta name="keywords" content="Vimalakirti的前端笔记，Vimalakirti的前端博客">
    <meta name="author" content="Vimalakirti,呛再首，枪在手">
    <link rel="preload" href="/Vimalate/assets/css/0.styles.0fc2bfa2.css" as="style"><link rel="preload" href="/Vimalate/assets/js/app.d87d40d0.js" as="script"><link rel="preload" href="/Vimalate/assets/js/2.302ef7ec.js" as="script"><link rel="preload" href="/Vimalate/assets/js/126.edd01363.js" as="script"><link rel="preload" href="/Vimalate/assets/js/3.89fcb6a6.js" as="script"><link rel="prefetch" href="/Vimalate/assets/js/10.db96971b.js"><link rel="prefetch" href="/Vimalate/assets/js/100.1cd7819d.js"><link rel="prefetch" href="/Vimalate/assets/js/101.9578b8db.js"><link rel="prefetch" href="/Vimalate/assets/js/102.bb75e7f1.js"><link rel="prefetch" href="/Vimalate/assets/js/103.ab46f274.js"><link rel="prefetch" href="/Vimalate/assets/js/104.f1ce2ab8.js"><link rel="prefetch" href="/Vimalate/assets/js/105.c95f5869.js"><link rel="prefetch" href="/Vimalate/assets/js/106.52ff5b74.js"><link rel="prefetch" href="/Vimalate/assets/js/107.ac023816.js"><link rel="prefetch" href="/Vimalate/assets/js/108.2ec61ebd.js"><link rel="prefetch" href="/Vimalate/assets/js/109.1481a2ea.js"><link rel="prefetch" href="/Vimalate/assets/js/11.f4df10e9.js"><link rel="prefetch" href="/Vimalate/assets/js/110.929ab33c.js"><link rel="prefetch" href="/Vimalate/assets/js/111.ed78738d.js"><link rel="prefetch" href="/Vimalate/assets/js/112.00ee8d94.js"><link rel="prefetch" href="/Vimalate/assets/js/113.1c8d7fe2.js"><link rel="prefetch" href="/Vimalate/assets/js/114.a3e3fa55.js"><link rel="prefetch" href="/Vimalate/assets/js/115.c6454f1c.js"><link rel="prefetch" href="/Vimalate/assets/js/116.337d8cca.js"><link rel="prefetch" href="/Vimalate/assets/js/117.87a24f0a.js"><link rel="prefetch" href="/Vimalate/assets/js/118.e8b2dccf.js"><link rel="prefetch" href="/Vimalate/assets/js/119.93fd9c39.js"><link rel="prefetch" href="/Vimalate/assets/js/12.099552e5.js"><link rel="prefetch" href="/Vimalate/assets/js/120.93b0be78.js"><link rel="prefetch" href="/Vimalate/assets/js/121.988e0315.js"><link rel="prefetch" href="/Vimalate/assets/js/122.34ed46da.js"><link rel="prefetch" href="/Vimalate/assets/js/123.6fc1b09e.js"><link rel="prefetch" href="/Vimalate/assets/js/124.a75d6e58.js"><link rel="prefetch" href="/Vimalate/assets/js/125.cbb4268a.js"><link rel="prefetch" href="/Vimalate/assets/js/127.44072a42.js"><link rel="prefetch" href="/Vimalate/assets/js/128.1fc86335.js"><link rel="prefetch" href="/Vimalate/assets/js/129.9ef146be.js"><link rel="prefetch" href="/Vimalate/assets/js/13.2bf4c31e.js"><link rel="prefetch" href="/Vimalate/assets/js/130.84c18e92.js"><link rel="prefetch" href="/Vimalate/assets/js/131.a0f338e9.js"><link rel="prefetch" href="/Vimalate/assets/js/132.a302180c.js"><link rel="prefetch" href="/Vimalate/assets/js/133.4de36bf4.js"><link rel="prefetch" href="/Vimalate/assets/js/134.607dc93a.js"><link rel="prefetch" href="/Vimalate/assets/js/14.fd32c07f.js"><link rel="prefetch" href="/Vimalate/assets/js/15.edb0e87f.js"><link rel="prefetch" href="/Vimalate/assets/js/16.f89d5e11.js"><link rel="prefetch" href="/Vimalate/assets/js/17.4469ae85.js"><link rel="prefetch" href="/Vimalate/assets/js/18.1bcf24fd.js"><link rel="prefetch" href="/Vimalate/assets/js/19.813b3402.js"><link rel="prefetch" href="/Vimalate/assets/js/20.06e695af.js"><link rel="prefetch" href="/Vimalate/assets/js/21.9b72d77f.js"><link rel="prefetch" href="/Vimalate/assets/js/22.96956599.js"><link rel="prefetch" href="/Vimalate/assets/js/23.e5fffe93.js"><link rel="prefetch" href="/Vimalate/assets/js/24.01efc919.js"><link rel="prefetch" href="/Vimalate/assets/js/25.ae396fa1.js"><link rel="prefetch" href="/Vimalate/assets/js/26.3384807a.js"><link rel="prefetch" href="/Vimalate/assets/js/27.1e0f8d29.js"><link rel="prefetch" href="/Vimalate/assets/js/28.6f6fac88.js"><link rel="prefetch" href="/Vimalate/assets/js/29.bf24166f.js"><link rel="prefetch" href="/Vimalate/assets/js/30.43115e77.js"><link rel="prefetch" href="/Vimalate/assets/js/31.5eaa06dd.js"><link rel="prefetch" href="/Vimalate/assets/js/32.62d4011b.js"><link rel="prefetch" href="/Vimalate/assets/js/33.807c49df.js"><link rel="prefetch" href="/Vimalate/assets/js/34.3123509f.js"><link rel="prefetch" href="/Vimalate/assets/js/35.b4be24f0.js"><link rel="prefetch" href="/Vimalate/assets/js/36.1ba29a04.js"><link rel="prefetch" href="/Vimalate/assets/js/37.af6e0a35.js"><link rel="prefetch" href="/Vimalate/assets/js/38.c8defce0.js"><link rel="prefetch" href="/Vimalate/assets/js/39.0a9387c4.js"><link rel="prefetch" href="/Vimalate/assets/js/4.f9cdb709.js"><link rel="prefetch" href="/Vimalate/assets/js/40.ae44237d.js"><link rel="prefetch" href="/Vimalate/assets/js/41.efed46b2.js"><link rel="prefetch" href="/Vimalate/assets/js/42.4da152b2.js"><link rel="prefetch" href="/Vimalate/assets/js/43.028a883c.js"><link rel="prefetch" href="/Vimalate/assets/js/44.cdcf6df0.js"><link rel="prefetch" href="/Vimalate/assets/js/45.9fdfefe7.js"><link rel="prefetch" href="/Vimalate/assets/js/46.e7818767.js"><link rel="prefetch" href="/Vimalate/assets/js/47.df3f6925.js"><link rel="prefetch" href="/Vimalate/assets/js/48.98ca1f5c.js"><link rel="prefetch" href="/Vimalate/assets/js/49.31e3047d.js"><link rel="prefetch" href="/Vimalate/assets/js/5.d3d41192.js"><link rel="prefetch" href="/Vimalate/assets/js/50.5e3a2447.js"><link rel="prefetch" href="/Vimalate/assets/js/51.caef9939.js"><link rel="prefetch" href="/Vimalate/assets/js/52.b0ae971b.js"><link rel="prefetch" href="/Vimalate/assets/js/53.5afad275.js"><link rel="prefetch" href="/Vimalate/assets/js/54.9cf1d8fd.js"><link rel="prefetch" href="/Vimalate/assets/js/55.e2ee0f16.js"><link rel="prefetch" href="/Vimalate/assets/js/56.9f79f5af.js"><link rel="prefetch" href="/Vimalate/assets/js/57.915335eb.js"><link rel="prefetch" href="/Vimalate/assets/js/58.bb60d992.js"><link rel="prefetch" href="/Vimalate/assets/js/59.2263e426.js"><link rel="prefetch" href="/Vimalate/assets/js/6.aa1f8785.js"><link rel="prefetch" href="/Vimalate/assets/js/60.56fdc0a2.js"><link rel="prefetch" href="/Vimalate/assets/js/61.73235b87.js"><link rel="prefetch" href="/Vimalate/assets/js/62.47bc1d08.js"><link rel="prefetch" href="/Vimalate/assets/js/63.05ebc122.js"><link rel="prefetch" href="/Vimalate/assets/js/64.3743b611.js"><link rel="prefetch" href="/Vimalate/assets/js/65.81e4f0f0.js"><link rel="prefetch" href="/Vimalate/assets/js/66.14ef0660.js"><link rel="prefetch" href="/Vimalate/assets/js/67.7e3b6645.js"><link rel="prefetch" href="/Vimalate/assets/js/68.d98b40f2.js"><link rel="prefetch" href="/Vimalate/assets/js/69.1e4098ec.js"><link rel="prefetch" href="/Vimalate/assets/js/7.28bb8430.js"><link rel="prefetch" href="/Vimalate/assets/js/70.02d7c6f9.js"><link rel="prefetch" href="/Vimalate/assets/js/71.1b38c9f2.js"><link rel="prefetch" href="/Vimalate/assets/js/72.f8ceb154.js"><link rel="prefetch" href="/Vimalate/assets/js/73.59d68c47.js"><link rel="prefetch" href="/Vimalate/assets/js/74.7baec790.js"><link rel="prefetch" href="/Vimalate/assets/js/75.f0e0f1eb.js"><link rel="prefetch" href="/Vimalate/assets/js/76.2b267b63.js"><link rel="prefetch" href="/Vimalate/assets/js/77.e2e6b40e.js"><link rel="prefetch" href="/Vimalate/assets/js/78.ca9545b4.js"><link rel="prefetch" href="/Vimalate/assets/js/79.96d0f8bb.js"><link rel="prefetch" href="/Vimalate/assets/js/8.6e87513b.js"><link rel="prefetch" href="/Vimalate/assets/js/80.b1bbb89b.js"><link rel="prefetch" href="/Vimalate/assets/js/81.6ae27928.js"><link rel="prefetch" href="/Vimalate/assets/js/82.cf8e186c.js"><link rel="prefetch" href="/Vimalate/assets/js/83.102f1aa8.js"><link rel="prefetch" href="/Vimalate/assets/js/84.2e9ea5b0.js"><link rel="prefetch" href="/Vimalate/assets/js/85.a69282b0.js"><link rel="prefetch" href="/Vimalate/assets/js/86.8fbbdbd3.js"><link rel="prefetch" href="/Vimalate/assets/js/87.031751b6.js"><link rel="prefetch" href="/Vimalate/assets/js/88.157805ee.js"><link rel="prefetch" href="/Vimalate/assets/js/89.399a3374.js"><link rel="prefetch" href="/Vimalate/assets/js/9.32addb21.js"><link rel="prefetch" href="/Vimalate/assets/js/90.845f026a.js"><link rel="prefetch" href="/Vimalate/assets/js/91.cf4b8f97.js"><link rel="prefetch" href="/Vimalate/assets/js/92.f0e7f99b.js"><link rel="prefetch" href="/Vimalate/assets/js/93.99a75e61.js"><link rel="prefetch" href="/Vimalate/assets/js/94.47e6cc5b.js"><link rel="prefetch" href="/Vimalate/assets/js/95.f039c196.js"><link rel="prefetch" href="/Vimalate/assets/js/96.b1507c6d.js"><link rel="prefetch" href="/Vimalate/assets/js/97.8a7b2831.js"><link rel="prefetch" href="/Vimalate/assets/js/98.6b2269bb.js"><link rel="prefetch" href="/Vimalate/assets/js/99.9bd5e8e4.js">
    <link rel="stylesheet" href="/Vimalate/assets/css/0.styles.0fc2bfa2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Vimalate/" class="home-link router-link-active"><img src="/Vimalate/resb.jpg" alt="博客首页" class="logo"> <span class="site-name can-hide">博客首页</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Vimalate/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Vimalate/blog/CSS-Library/那些奇妙的 CSS .html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/Vimalate/blog/Javascript-Library/聊聊原型和原型链.html" class="nav-link">
  Javascript
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="每日学习" class="dropdown-title"><span class="title">每日学习</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Vimalate/LeetCode-Library/121-买卖股票最佳时机.html" class="nav-link">
  LeetCode
</a></li><li class="dropdown-item"><!----> <a href="/Vimalate/blog/CSS-Library/CSS-study.html" class="nav-link">
  琐碎
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="每日学习" class="dropdown-title"><span class="title">在线作品</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="http://vimalakirti.fun/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  静墨书城
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://vimalate.github.io/travel/dist" target="_blank" rel="noopener noreferrer" class="nav-link external">
  携程旅行
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="nav-item"><a href="https://github.com/Vimalate" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Vimalate/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Vimalate/blog/CSS-Library/那些奇妙的 CSS .html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/Vimalate/blog/Javascript-Library/聊聊原型和原型链.html" class="nav-link">
  Javascript
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="每日学习" class="dropdown-title"><span class="title">每日学习</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Vimalate/LeetCode-Library/121-买卖股票最佳时机.html" class="nav-link">
  LeetCode
</a></li><li class="dropdown-item"><!----> <a href="/Vimalate/blog/CSS-Library/CSS-study.html" class="nav-link">
  琐碎
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="每日学习" class="dropdown-title"><span class="title">在线作品</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="http://vimalakirti.fun/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  静墨书城
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://vimalate.github.io/travel/dist" target="_blank" rel="noopener noreferrer" class="nav-link external">
  携程旅行
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="nav-item"><a href="https://github.com/Vimalate" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>HTML</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Vimalate/blog/HTML-Library/HTML-Study.html" class="sidebar-link">常见HTML问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Vimalate/blog/CSS-Library/那些奇妙的 CSS .html" class="sidebar-link">那些奇妙的 CSS</a></li><li><a href="/Vimalate/blog/CSS-Library/CSS-study.html" class="sidebar-link">CSS技巧</a></li><li><a href="/Vimalate/blog/CSS-Library/我都知道的CSS.html" class="sidebar-link">我都知道的CSS</a></li><li><a href="/Vimalate/blog/CSS-Library/layout.html" class="sidebar-link">常见布局技巧</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Javascript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Vimalate/blog/Javascript-Library/聊聊原型和原型链.html" class="sidebar-link">聊聊原型和原型链</a></li><li><a href="/Vimalate/blog/Javascript-Library/js继承.html" class="sidebar-link">js里的继承</a></li><li><a href="/Vimalate/blog/Javascript-Library/js存储和垃圾回收.html" class="sidebar-link">js存储和垃圾回收</a></li><li><a href="/Vimalate/blog/Javascript-Library/new.html" class="sidebar-link">new一个对象发生了什么</a></li><li><a href="/Vimalate/blog/Javascript-Library/了解Event Loop么.html" class="sidebar-link">了解Event Loop么</a></li><li><a href="/Vimalate/blog/Javascript-Library/ES6的Set ，WeakSet，Map和WeakMap.html" class="sidebar-link">ES6的Set ，WeakSet，Map和WeakMap</a></li><li><a href="/Vimalate/blog/Javascript-Library/常见数组方法.html" class="sidebar-link">常见数组方法</a></li><li><a href="/Vimalate/blog/Javascript-Library/我都知道的JS.html" class="sidebar-link">我都知道的JS</a></li><li><a href="/Vimalate/blog/Javascript-Library/Javascript 面试题.html" class="sidebar-link">Javascript 面试题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Vimalate/blog/VUE-Library/vue响应原理.html" class="sidebar-link">vue响应原理</a></li><li><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html" class="active sidebar-link">vue 整理面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#生命周期钩子函数" class="sidebar-link">生命周期钩子函数</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#父子组件生命周期调用顺序" class="sidebar-link">父子组件生命周期调用顺序</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#react-和-vue的区别" class="sidebar-link">React 和 Vue的区别</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#组件通信" class="sidebar-link">组件通信</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#mixin-和-mixins-区别" class="sidebar-link">mixin 和 mixins 区别</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#computed-的实现原理" class="sidebar-link">computed 的实现原理</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#computed-和-watch-区别" class="sidebar-link">computed 和 watch 区别</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#v-show-与-v-if-区别" class="sidebar-link">v-show 与 v-if 区别</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#vue中组件的data为什么是一个函数" class="sidebar-link">vue中组件的data为什么是一个函数</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#vue-插槽的使用" class="sidebar-link">vue 插槽的使用</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#nexttick的用途与原理" class="sidebar-link">nextTick的用途与原理</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#proxy-与-object-defineproperty-的优劣对比" class="sidebar-link">Proxy 与 Object.defineProperty 的优劣对比</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#观察者模式与发布-订阅模式的区别" class="sidebar-link">观察者模式与发布-订阅模式的区别</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#v-for和v-if一起使用" class="sidebar-link">v-for和v-if一起使用</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#v-for中的key不建议使用index" class="sidebar-link">v-for中的key不建议使用index</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#了解-virtual-dom？为什么-virtual-dom-比原生-dom-快？" class="sidebar-link">了解 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#如何比较两个-dom-树的差异？" class="sidebar-link">如何比较两个 DOM 树的差异？</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#vue的渲染过程" class="sidebar-link">Vue的渲染过程</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#hash路由和history路由" class="sidebar-link">hash路由和history路由</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#vue-项目的一些优化？" class="sidebar-link">Vue 项目的一些优化？</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#为什么使用异步组件" class="sidebar-link">为什么使用异步组件</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#components和-vue-component" class="sidebar-link">components和 Vue.component</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#如何在不刷新页面的情况下，刷新组件？" class="sidebar-link">如何在不刷新页面的情况下，刷新组件？</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#路由懒加载" class="sidebar-link">路由懒加载</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#vue路由按需加载" class="sidebar-link">vue路由按需加载</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#keep-alive原理" class="sidebar-link">keep-alive原理</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#vue-router-导航守卫有哪些" class="sidebar-link">Vue-router 导航守卫有哪些</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#vue-router-传参" class="sidebar-link">vue-router 传参</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#route-和-router-的区别？" class="sidebar-link">$route 和 $router 的区别？</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#组件渲染和更新过程" class="sidebar-link">组件渲染和更新过程</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#provide-inject-使用" class="sidebar-link">provide / inject 使用</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#简单介绍-一下-vuex" class="sidebar-link">简单介绍 一下 Vuex</a></li><li class="sidebar-sub-header"><a href="/Vimalate/blog/VUE-Library/vue 整理面试题.html#为什么-vuex-的-mutation-中不能做异步操作" class="sidebar-link">为什么 Vuex 的 mutation 中不能做异步操作</a></li></ul></li><li><a href="/Vimalate/blog/VUE-Library/vue项目问题总结.html" class="sidebar-link">vue项目问题总结</a></li><li><a href="/Vimalate/blog/VUE-Library/vue项目路由权限配置.html" class="sidebar-link">vue项目权限配置</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Other</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工程化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Vimalate/blog/Other-Library/Git Document Library/github搜索.html" class="sidebar-link">github搜索</a></li><li><a href="/Vimalate/blog/Other-Library/Git Document Library/git常用命令和开发流程.html" class="sidebar-link">git常用命令和开发流程</a></li><li><a href="/Vimalate/blog/Other-Library/skill/git优雅提交.html" class="sidebar-link">git优雅提交</a></li><li><a href="/Vimalate/blog/Other-Library/Git Document Library/npm发布包.html" class="sidebar-link">npm发布包</a></li><li><a href="/Vimalate/blog/Other-Library/前端协作规范.html" class="sidebar-link">前端协作规范</a></li><li><a href="/Vimalate/blog/Other-Library/错误监控.html" class="sidebar-link">错误监控</a></li><li><a href="/Vimalate/blog/Other-Library/Git Document Library/webpack面试题.html" class="sidebar-link">webpack面试题</a></li><li><a href="/Vimalate/blog/Other-Library/Git Document Library/gitbook.html" class="sidebar-link">gitbook 遇到的问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端技巧</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Vimalate/blog/Other-Library/skill/skill.html" class="sidebar-link">前端常用技巧</a></li><li><a href="/Vimalate/blog/Other-Library/skill/项目利器.html" class="sidebar-link">前端常用库</a></li><li><a href="/Vimalate/blog/Other-Library/skill/vscode常见操作.html" class="sidebar-link">vscode常见操作</a></li><li><a href="/Vimalate/blog/VUE-Library/self.html" class="sidebar-link">self</a></li><li><a href="/Vimalate/blog/Other-Library/skill/vscode那些老板键.html" class="sidebar-link">vscode那些老板键</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-常见面试整理"><a href="#vue-常见面试整理" class="header-anchor">#</a> VUE 常见面试整理</h1> <h2 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="header-anchor">#</a> 生命周期钩子函数</h2> <p><strong>beforeCreate（初始化界面前）</strong></p> <p><strong>created（初始化界面后）</strong></p> <p><strong>beforeMount（渲染dom前）</strong></p> <p><strong>mounted（渲染dom后）</strong></p> <p><strong>beforeUpdate（更新数据前）</strong></p> <p><strong>updated（更新数据后）</strong></p> <p><strong>beforeDestroy（卸载组件前）</strong></p> <p><strong>destroyed（卸载组件后）</strong></p> <p><strong>钩子函数，其实和回调是一个概念</strong>，当系统执行到某处时，检查是否有hook，有则回调。说的更直白一点，每个组件都有属性，方法和事件。所有的生命周期都归于事件，在某个时刻自动执行。<strong>生老病死</strong></p> <p>我们首先需要创建一个实例，也就是在 n<strong>ew Vue ( ) 的对象过程当中，首先执行了init</strong>（init是vue组件里面默认去执行的），在<strong>init的过程当中</strong>首先调用了<strong>beforeCreate</strong>，然后在injections（注射）和reactivity（反应性）的时候，它会再去调用created。所以在init的时候，事件已经调用了，我们在beforeCreate的时候千万不要去修改data里面赋值的数据，最早也要放在created里面去做（添加一些行为）。</p> <p>created完成之后，它会去<strong>判断instance（实例）里面是否含有“el”option（选项）</strong>，如果<strong>没有</strong>的话，它会调用<strong>vm.$mount(el)<strong>这个方法，然后执行下一步；如果</strong>有</strong>的话，<strong>直接执行下一步</strong>。紧接着会<strong>判断是否含有“template”这个选项</strong>，如果<strong>有</strong>的话，它会<strong>把template解析成一个render function</strong> ，即template编译的过程，结果是解析成了render函数</p> <p><strong>render函数是发生在beforeMount和mounted之间的</strong>，这也从侧面说明了，在<strong>beforeMount</strong>的时候，<strong>$el还只是我们在HTML里面写的节点</strong>，然后到<strong>mounted</strong>的时候，它就把<strong>渲染出来的内容挂载到了DOM节点上</strong>。这中间的过程其实是执行了render function的内容。</p> <p>beforeMount在有了render function的时候才会执行，当执行完render function之后，就会调用mounted这个钩子，在mounted挂载完毕之后，这个实例就算是走完流程了。</p> <p>另外还有 <code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>actived</code> 钩子函数。</p> <h2 id="父子组件生命周期调用顺序"><a href="#父子组件生命周期调用顺序" class="header-anchor">#</a> 父子组件生命周期调用顺序</h2> <p>父组件初始化完，再初始化子组件</p> <p>子组件渲染完，再渲染父组件</p> <p><img src="https://i.loli.net/2020/04/20/RJFVdzEpo9Btc5n.png" alt=""></p> <p>同理，组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</p> <h2 id="react-和-vue的区别"><a href="#react-和-vue的区别" class="header-anchor">#</a> React 和 Vue的区别</h2> <ul><li><p>设计思想:</p> <p>vue的官网中说它是一款渐进式框架，采用自底向上增量开发的设计。</p> <p>react主张函数式编程，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以手动实现，比如借助 onChange 和 setState 来实现一个双向的数据流。</p></li> <li><p>编写语法:</p> <p>Vue推荐的做法是webpack+vue-loader的单文件组件格式，vue保留了html、css、js分离的写法</p> <p>React的开发者可能知道，react是没有模板的，直接就是一个渲染函数，它中间返回的就是一个虚拟DOM树，React推荐的做法是 JSX+inline style，也就是把 html 和 css 都写进js里，即<code>all in js</code></p></li> <li><p>构建工具:</p> <p>vue提供了CLI 脚手架，可以帮助你非常容易地构建项目</p> <p>React 在这方面也提供了 create-react-app，但是现在还存在一些局限性，不能配置等等</p></li> <li><p>数据绑定:</p> <p>vue是实现了双向数据绑定的mvvm框架，当视图改变更新模型层，当模型层改变更新视图层。
在vue中，使用了双向绑定技术，就是View的变化能实时让Model发生变化，而Model的变化也能实时更新到View。</p> <p>react是单向数据流，react中属性是不允许更改的，状态是允许更改的。
react中组件不允许通过this.state这种方式直接更改组件的状态。自身设置的状态，可以通过setState来进行更改。
(注意：React中setState是异步的，导致获取dom可能拿的还是之前的内容，
所以我们需要在setState第二个参数（回调函数）中获取更新后的新的内容。)</p></li> <li><p>diff算法:</p> <p>vue中diff算法实现流程:</p> <div class="language- extra-class"><pre><code>1. 内存中构建虚拟 dom
2. 将内存中虚拟 dom 渲染成真实 dom
3. 当数据发生改变时，将之前的虚拟 dom 树结合新的数据生成新的虚拟 dom
4. 将此次生成好的虚拟dom树和上一次的虚拟dom树进行一次比对(diff算法进行比对)，来更新只需要被替换的DOM，而不是全部重绘。在Diff算法中，只平层的比较前后两棵DOM树的节点，没有进行深度的遍历。
5. 会将对比出来的差异进行重新渲染
</code></pre></div><p>react中diff算法实现流程:</p> <div class="language- extra-class"><pre><code>DOM结构发生改变-----直接卸载并重新create
DOM结构一样-----不会卸载,但是会update变化的内容
所有同一层级的子节点.他们都可以通过key来区分-----同时遵循1.2两点(其实这个key的存在与否只会影响diff算法的复杂度,换言之,你不加key的情况下,diff算法就会以暴力的方式去根据一二的策略更新,但是你加了key,diff算法会引入一些另外的操作)
</code></pre></div></li></ul> <p>参考:<a href="https://juejin.im/post/5dad09be518825393e52d1bd" target="_blank" rel="noopener noreferrer">前端框架用vue还是react？清晰对比两者差异<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="组件通信"><a href="#组件通信" class="header-anchor">#</a> 组件通信</h2> <ul><li>父子组件通信</li> <li>兄弟组件通信</li> <li>跨多层级组件通信</li> <li>任意组件</li></ul> <h3 id="父子"><a href="#父子" class="header-anchor">#</a> 父子</h3> <p>父组件通过 <code>props</code> 传递数据给子组件，子组件通过 <code>emit</code> 发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。  <strong>单向数据流</strong>，父组件通过 <code>props</code> 传递数据，子组件不能直接修改 <code>props</code>， 而是必须通过发送事件的方式告知父组件修改数据。父组件通过v-on监听并接收参数</p> <p>当然我们还可以通过访问 <code>$parent</code> 或者 <code>$children</code> 对象来访问组件实例中的方法和数据。</p> <p><strong>v-model</strong></p> <p>因为 <code>v-model</code> 默认会解析成名为 <code>value</code> 的 <code>prop</code> 和名为 <code>input</code> 的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。</p> <div class="language-! extra-class"><pre class="language-text"><code>在一个组件上使用v-model，默认会为组件绑定名为value的prop和名为input的事件
</code></pre></div><h3 id="兄弟"><a href="#兄弟" class="header-anchor">#</a> <strong>兄弟</strong></h3> <h4 id="eventbus"><a href="#eventbus" class="header-anchor">#</a> <strong>eventBus</strong></h4> <p>初始化：</p> <div class="language- extra-class"><pre class="language-text"><code>// event-bus.js

import Vue from 'vue'
export const EventBus = new Vue()

</code></pre></div><p>兄弟组件通过EventBus.$emit分发和EventBus.$on接收</p> <h4 id="children-parent"><a href="#children-parent" class="header-anchor">#</a> <code>$children</code> / <code>$parent</code></h4> <p>对于这种情况可以通过查找父组件中的子组件实现，也就是 <code>this.$parent.$children</code>，在 <code>$children</code>中可以通过组件 <code>name</code> 查询到需要的组件实例，然后进行通信。</p> <h2 id="mixin-和-mixins-区别"><a href="#mixin-和-mixins-区别" class="header-anchor">#</a> mixin 和 mixins 区别</h2> <p><code>mixin</code> 用于全局混入，以全局混入封装好的 <code>ajax</code> 或者一些工具函数等等。</p> <p><code>mixins</code> 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 <code>mixins</code> 混入代码，比如上拉下拉加载数据这种逻辑等等。</p> <div class="language-! extra-class"><pre class="language-text"><code>需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读
</code></pre></div><p><a href="https://cn.vuejs.org/v2/guide/mixins.html" target="_blank" rel="noopener noreferrer">文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="computed-的实现原理"><a href="#computed-的实现原理" class="header-anchor">#</a> computed 的实现原理</h2> <p>computed 是一个惰性求值的观察者</p> <p>它的内部实现了一个惰性的 watcher ，即computed wathcer，computed wathcer 不会立即求值，同时拥有一个 dep 实例。内部通过 <code>this.dirty</code>属性来标记计算是否需要重新求值</p> <p>当 computed 的依赖状态发生改变时,就会通知这个惰性的 watcher,</p> <p>computed watcher 通过 this.dep.subs.length 判断有没有订阅者,有的话,会重新计算,然后对比新旧值,如果变化了,会重新渲染。 (Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化时才会触发渲染 watcher 重新渲染，本质上是一种优化。)
没有的话,仅仅把 this.dirty = true。 (当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性。)</p> <h2 id="computed-和-watch-区别"><a href="#computed-和-watch-区别" class="header-anchor">#</a> computed 和 watch 区别</h2> <p><code>computed</code> 是计算属性，依赖其他属性计算值，并且 <code>computed</code> 的值有<strong>缓存</strong>，只有当计算值变化才会返回内容。内部做了一个一个 dirty ,实现缓存。当依赖的属性发生变化，就会让 dirty 变为true</p> <p><code>watch</code> 监听到值的变化就会**执行回调，**在回调中可以进行一些逻辑操作。可设置 deep:true 深层次监听，利用递归实现。</p> <p>所以一般来说需要依赖别的属性来动态获得值的时候可以使用 <code>computed</code>，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 <code>watch</code>。</p> <h2 id="v-show-与-v-if-区别"><a href="#v-show-与-v-if-区别" class="header-anchor">#</a> v-show 与 v-if 区别</h2> <p><code>v-show</code> 无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。<code>display:none</code>属性，<strong>所以总的来说 <code>v-show</code> 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。</strong>，v-show是控制有没有display：none这个样式来控制显隐。</p> <p><code>v-if</code> 条件渲染，切换条件时会<strong>触发销毁/挂载组件，<strong>所以总的来说在切</strong>换时开销更高，更适合不经常切换的场景。</strong></p> <h2 id="vue中组件的data为什么是一个函数"><a href="#vue中组件的data为什么是一个函数" class="header-anchor">#</a> vue中组件的data为什么是一个函数</h2> <p>组件是可复用的vue实例，一个组件被创建好之后，就可能被用在各个地方，而组件不管被复用了多少次，组件中的data数据都应该是相互隔离，互不影响的。</p> <p>组件中的data 写成函数，数据以函数返回值定义，这样每复用一次组件，就能够获得一份独立的 data 拷贝，互不影响。原因在于采用函数定义，在 initData 时会将其作为工厂函数返回全新的 data 对象，有效规避多组件间的状态污染。</p> <div class="language-! extra-class"><pre class="language-text"><code>而在 Vue 根实例创建则不存在此限制，因为根实例只有一个。无须担心此状况。
</code></pre></div><h2 id="vue-插槽的使用"><a href="#vue-插槽的使用" class="header-anchor">#</a> vue 插槽的使用</h2> <ul><li>匿名插槽</li> <li>具名插槽</li> <li>作用域插槽</li></ul> <p>具体用法可<a href="https://juejin.im/post/5a69ece0f265da3e5a5777ed" target="_blank" rel="noopener noreferrer">参考<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://juejin.im/post/5cb0564e5188251acb530087" target="_blank" rel="noopener noreferrer">slot详解<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://juejin.im/post/5da72b3fe51d4524cf450f8e" target="_blank" rel="noopener noreferrer">从一个简单的 list 组件搞懂 Vue 插槽<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="nexttick的用途与原理"><a href="#nexttick的用途与原理" class="header-anchor">#</a> nextTick的用途与原理</h2> <p>应用场景 ：需要在试图更新后，基于新的视图进行操作。</p> <p>例：点击按钮让原本隐藏的输入框显示，并且获取焦点</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>input v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">'isShow'</span> id<span class="token operator">=</span><span class="token string">'keywords'</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">&quot;showInput&quot;</span><span class="token operator">&gt;</span>输入框显示，并且获取焦点<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>

<span class="token function">showInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>isShow<span class="token operator">=</span><span class="token boolean">true</span>
	<span class="token comment">// document.getElementById('keywords').focus //获取不到输入框报错</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// DOM 更新了,可以获取</span>
    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;keywords&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//加上$nextTick </span>
<span class="token punctuation">}</span>

</code></pre></div><p>vue 的数据响应通过 <code>Object.defineProperty</code> 实现，而 vue 更新 dom 是异步的，官方这样解释：</p> <blockquote><p>Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的Promise.then和 MessageChannel，如果执行环境不支持，会采用setTimeout(fn, 0)代替。</p></blockquote> <p>即 nextTick 原理与 Event Loop 相关</p> <p>事件循环又分为</p> <p>macro-task(宏任务)包括：</p> <ul><li>script(整体代码)</li> <li>setTimeout / setInterval</li> <li>setImmediate(Node.js 环境)</li> <li>I/O</li> <li>UI render</li> <li>postMessage</li> <li>MessageChannel</li></ul> <blockquote><p>不建议记住宏任务，太多，记住以下微任务即可，其他不知道的把其归类为宏任务（当然，此仅为面试时技巧）</p></blockquote> <p>micro-task(微任务)：</p> <ul><li>process.nextTick(Node.js 环境)</li> <li>Promise</li> <li>Async/Await</li> <li>MutationObserver(html5 新特性)</li></ul> <p>所有微任务都会在下一次渲染前完成，目的是在渲染前更新应用程序状态。</p> <p><strong>关于事件循环执行顺序总结与速记：</strong>
先执行主线程
遇到宏队列（macrotask）放到宏队列（macrotask）
遇到微队列（microtask）放到微队列（microtask）
主线程执行完毕
执行微队列（microtask），微队列（microtask）执行完毕
执行一次宏队列（macrotask）中的一个任务，执行完毕
执行微队列（microtask），执行完毕
依次循环。。。</p> <p>nextTick 的主要实现依赖于 微任务，但 Vue 为了做好一些兼容，优先使用 promise ，其次是 html5 的 MutationObserver，然后是setTimeout。前两者属于microtask，后一个属于 macrotask。</p> <p>优先尝试 Promise ，尝试 MutationObserver，尝试 setImmediate，最终不行在使用 setTimeout</p> <p>参考：<a href="https://juejin.im/post/5e899111f265da47d4056689" target="_blank" rel="noopener noreferrer">从 javascript 事件循环看 Vue.nextTick 的原理和执行机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="proxy-与-object-defineproperty-的优劣对比"><a href="#proxy-与-object-defineproperty-的优劣对比" class="header-anchor">#</a> Proxy 与 Object.defineProperty 的优劣对比</h2> <p>proxy 优势 ：</p> <ul><li>能直接监听数组的变化</li> <li>能直接监听对象而非属性</li> <li>多达 13 种拦截方法，不限于 apply、ownKeys、deleteProperty、has等等是 Object.defineProperty 所不具备的</li> <li>返回一个新对象，我们的操作只对于新对象，而 Object.defineProperty 只能遍历对象属性进行更改</li> <li>性能红利</li></ul> <blockquote><p>在Vue中，Object.defineProperty无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。 为了解决这个问题，经过vue内部处理后可以使用以下几种方法来监听数组
（其实，Object.defineProperty本身是可以监控到数组下标的变化的，具体可参<a href="https://segmentfault.com/a/1190000015783546#comment-area" target="_blank" rel="noopener noreferrer">Vue为什么不能检测数组变动<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）</p></blockquote> <h2 id="观察者模式与发布-订阅模式的区别"><a href="#观察者模式与发布-订阅模式的区别" class="header-anchor">#</a> 观察者模式与发布-订阅模式的区别</h2> <p><strong>观察者模式</strong></p> <p>观察者模式是一种行为模式，它定义了一种一对多的依赖关系。让多个观察者对象同时监听某一个主体对象，这个主体对象发生状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p> <p><strong>发布-订阅模式</strong></p> <p>发布-订阅模式，发布消息的一方叫做发布者，消息不会发送给特定的接收者，而是通过一个第三方组件，也叫作信息中介，意思是发布者和订阅者并不知道对方的存在。这个信息中介把发布者和订阅者串联起来，由它来过滤和分配所有输入的消息。</p> <p><strong>差异总结</strong></p> <ul><li><p>在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。</p></li> <li><p>发布-订阅模式中，组件时松散耦合的，和观察者模式相反</p></li> <li><p>观察者模式大多数时候是同步的，例如当事件触发，Subject就会去调用观察者的方法，而发布-订阅模式大多数时候是异步的（使用消息队列）。</p></li> <li><p>观察者 模式需要在单个应用程序地址空间中实现，而发布-订阅更像交叉应用模式</p></li></ul> <h2 id="v-for和v-if一起使用"><a href="#v-for和v-if一起使用" class="header-anchor">#</a> v-for和v-if一起使用</h2> <p>v-for和v-if同时使用时，有一个先后运行的优先级。因为v-for比v-if优先级更高，所以当两者用于同一标签时，v-for的每次循环中都会调用v-if。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费。</p> <p><strong>解决方法</strong>：ul和li搭配使用，或者是渲染父级标签下的子标签</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>ul v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">&quot;data&quot;</span><span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>li v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">&quot;(item,id) in list&quot;</span> <span class="token operator">:</span>key<span class="token operator">=</span><span class="token string">&quot;id&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
</code></pre></div><p><strong>或使用过滤器将v-if中的判断转移到vue的computed的计算属性中</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>li v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">&quot;(item,id) in list&quot;</span> <span class="token operator">:</span>key<span class="token operator">=</span><span class="token string">&quot;id&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
 
<span class="token comment">//利用vue的计算属性，过滤掉不需要的数据，剩下需要的数据再利用v-for循环遍历取出渲染</span>
computed<span class="token operator">:</span> <span class="token punctuation">{</span>
	<span class="token function-variable function">list</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> item<span class="token punctuation">.</span>state
		<span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="v-for中的key不建议使用index"><a href="#v-for中的key不建议使用index" class="header-anchor">#</a> v-for中的key不建议使用index</h2> <p>我们使用 v-for 时，其内部 diff 算法使用就地复用原则，当列表数据发生更改，他是根据 key 值来判断某个值是否修改，如修改，则重新渲染，否则就复用这一项。key的作用也主要是为了高效的更新虚拟DOM，而 index 则不能做到。</p> <p>也就是说如果你的列表顺序会改变，别用 index 作为 key，和没写基本上没区别，因为不管你数组的顺序怎么颠倒，index 都是 0, 1, 2 这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。列表顺序不变也尽量别用，可能会误导新人。
<a href="https://juejin.im/post/5aae19aa6fb9a028d4445d1a" target="_blank" rel="noopener noreferrer">具体参考： v-for中的key<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="了解-virtual-dom？为什么-virtual-dom-比原生-dom-快？"><a href="#了解-virtual-dom？为什么-virtual-dom-比原生-dom-快？" class="header-anchor">#</a> 了解 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</h2> <p>Virtual DOM 其实就是通过对文档中的 DOM 树结构进行分析，利用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</p> <p>当我们的页面要发生改变，也就是页面 DOM 结构调整，我们首先根据变更的状态，重新构建起一棵对象树，然后将新树和旧树进行对比，记录下两棵树的差异。</p> <p>最后将有差异的地方进行替换，应用到真正的 DOM 树中，然后视图也就完成更新。</p> <p><strong>这种方法在我们需要大量的 DOM 操作时，能够很好的提高我们的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘的影响。其实 Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。</strong></p> <h2 id="如何比较两个-dom-树的差异？"><a href="#如何比较两个-dom-树的差异？" class="header-anchor">#</a> 如何比较两个 DOM 树的差异？</h2> <p>两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。</p> <p>算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。</p> <p>在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。</p> <div class="language-! extra-class"><pre class="language-text"><code>diff 过程整体遵循 **深度优先、同层比较**的策略：两个节点比较他们是否拥有子节点或者文本节点做不同的操作，当比较两组子节点时，会先假设头尾节点相同做四次比较尝试，如果没有找到相同节点则按照通用方式遍历查找，查找结束再按情况处理剩下的节点，借助 key 通常可以更高效精确的找到相同节点，然后复用，因此整个 patch 过程也非常的高效。
</code></pre></div><h2 id="vue的渲染过程"><a href="#vue的渲染过程" class="header-anchor">#</a> Vue的渲染过程</h2> <ol><li>把模板编译为 render 函数</li> <li>实例进行挂载，执行 render 函数，生成 vnode</li> <li>基于 vnode 执行 diff 算法，对比虚拟 dom，渲染真实 dom</li> <li>组件内的 data 发生变化时，重新调用 render 函数，生成 vnode ，然后又回到步骤3了。</li></ol> <h2 id="hash路由和history路由"><a href="#hash路由和history路由" class="header-anchor">#</a> hash路由和history路由</h2> <ul><li>hash模式：依靠onhashchange事件(监听location.hash的改变)</li> <li>history模式：history.pushState 和 replaceState ，pushState()可以改变url地址且不会发送请求，replaceState()可以读取历史记录栈,还可以对浏览器记录进行修改。</li></ul> <h2 id="vue-项目的一些优化？"><a href="#vue-项目的一些优化？" class="header-anchor">#</a> Vue 项目的一些优化？</h2> <p>代码层面优化：</p> <ul><li>v-if 和 v-show 区分使用</li> <li>v-for 加key ，避免同时使用 v-if</li> <li>路由懒加载</li> <li>图片懒加载 v-lazy</li> <li>事件及时销毁</li> <li>第三方插件按需引入</li></ul> <p>Webpack 层面：</p> <ul><li>对图片进行压缩</li> <li>模板预编译</li> <li>优化 SourceMap</li> <li>提取公共代码</li></ul> <p>基础的 Web 技术的优化：</p> <ul><li>开启 gzip</li> <li>使用 cdn</li> <li>浏览器缓存</li> <li>使用 Chrome Performance 查找性能瓶颈</li></ul> <p><a href="https://juejin.im/post/5d548b83f265da03ab42471d#heading-13" target="_blank" rel="noopener noreferrer">具体各优化方法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="为什么使用异步组件"><a href="#为什么使用异步组件" class="header-anchor">#</a> 为什么使用异步组件</h2> <p>项目过大时，核心页面访问速度变慢，使用异步组件将代码分割成小块，需要使用这个组件时在引入，可提高加载的速度。主要依赖<code>import()</code>这个语法。
用法示例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    components<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">Home</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./components/Home'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>异步组件的渲染本质上其实就是执行2次或者2次以上的渲染, 先把当前组件渲染为注释节点, 当组件加载成功后, 通过 forceRender 执行重新渲染。或者是渲染为注释节点, 然后再渲染为loading节点, 在渲染为请求完成的组件</p> <h2 id="components和-vue-component"><a href="#components和-vue-component" class="header-anchor">#</a> components和 Vue.component</h2> <ul><li>components:局部注册组件</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
  components<span class="token operator">:</span><span class="token punctuation">{</span>home<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>Vue.component:全局注册组件</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'home'</span><span class="token punctuation">,</span>home<span class="token punctuation">)</span>
</code></pre></div><h2 id="如何在不刷新页面的情况下，刷新组件？"><a href="#如何在不刷新页面的情况下，刷新组件？" class="header-anchor">#</a> 如何在不刷新页面的情况下，刷新组件？</h2> <p>方法：</p> <ul><li>v-if</li> <li>$forceUpdate()</li> <li>v-key</li></ul> <h2 id="路由懒加载"><a href="#路由懒加载" class="header-anchor">#</a> 路由懒加载</h2> <p>路由懒加载就是把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件。</p> <p>实现：使用命名 chunk ，和 webpack 的魔法注释</p> <div class="language-js extra-class"><pre class="language-js"><code>chunkconst <span class="token function-variable function">Home</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName: &quot;group-home&quot; */</span> <span class="token string">'./Home.vue'</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="vue路由按需加载"><a href="#vue路由按需加载" class="header-anchor">#</a> vue路由按需加载</h2> <ol><li>写两个 <code>router-view</code>出口</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive <span class="token operator">:</span>include<span class="token operator">=</span><span class="token string">&quot;include&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 需要缓存的视图组件 <span class="token operator">--</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>router<span class="token operator">-</span>view v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">&quot;$route.meta.keepAlive&quot;</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>keep<span class="token operator">-</span>alive<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 不需要缓存的视图组件 <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>view v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">&quot;!$route.meta.keepAlive&quot;</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">&gt;</span>
</code></pre></div><ol start="2"><li>在Router里定义好需要缓存的视图组件</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    routes<span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
            path<span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>
            name<span class="token operator">:</span> <span class="token string">'index'</span><span class="token punctuation">,</span>
            <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./views/keep-alive/index.vue'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            meta<span class="token operator">:</span> <span class="token punctuation">{</span>
                deepth<span class="token operator">:</span> <span class="token number">0.5</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
            path<span class="token operator">:</span> <span class="token string">'/list'</span><span class="token punctuation">,</span>
            name<span class="token operator">:</span> <span class="token string">'list'</span><span class="token punctuation">,</span>
            <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./views/keep-alive/list.vue'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            meta<span class="token operator">:</span> <span class="token punctuation">{</span>
                deepth<span class="token operator">:</span> <span class="token number">1</span>
                keepAlive<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">//需要被缓存</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
            path<span class="token operator">:</span> <span class="token string">'/detail'</span><span class="token punctuation">,</span>
            name<span class="token operator">:</span> <span class="token string">'detail'</span><span class="token punctuation">,</span>
            <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./views/keep-alive/detail.vue'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            meta<span class="token operator">:</span> <span class="token punctuation">{</span>
                deepth<span class="token operator">:</span> <span class="token number">2</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ol start="3"><li>在app.vue里监听路由的变化</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;app&quot;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">data</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    include<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  watch<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">$route</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//如果 要 to(进入) 的页面是需要 keepAlive 缓存的，把 name push 进 include数组</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">.</span>meta<span class="token punctuation">.</span>keepAlive<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>include<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>include<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">//如果 要 form(离开) 的页面是 keepAlive缓存的，</span>
      <span class="token comment">//再根据 deepth 来判断是前进还是后退</span>
      <span class="token comment">//如果是后退</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>keepAlive <span class="token operator">&amp;&amp;</span> to<span class="token punctuation">.</span>meta<span class="token punctuation">.</span>deepth <span class="token operator">&lt;</span> <span class="token keyword">from</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>deepth<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> index <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>include<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        index <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>include<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p><a href="https://juejin.im/post/5cdcbae9e51d454759351d84" target="_blank" rel="noopener noreferrer">详情<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="keep-alive原理"><a href="#keep-alive原理" class="header-anchor">#</a> keep-alive原理</h2> <p><a href="https://juejin.im/post/5a08f72ef265da43133ca41f" target="_blank" rel="noopener noreferrer">详细<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="vue-router-导航守卫有哪些"><a href="#vue-router-导航守卫有哪些" class="header-anchor">#</a> Vue-router 导航守卫有哪些</h2> <ul><li>全局钩子：<code>beforeEach、beforeResolve、afterEach</code></li> <li>路由独享守卫：<code>beforeEnter</code></li> <li>组件内守卫： <code>beforeRouteEnter 、beforeRouteUpdate、beforeRouteLeave</code></li></ul> <h2 id="vue-router-传参"><a href="#vue-router-传参" class="header-anchor">#</a> vue-router 传参</h2> <p>query方式传参和接收参数</p> <div class="language-js extra-class"><pre class="language-js"><code>传参<span class="token operator">:</span> 
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        path<span class="token operator">:</span><span class="token string">'/xxx'</span><span class="token punctuation">,</span>
        query<span class="token operator">:</span><span class="token punctuation">{</span>
          id<span class="token operator">:</span>id
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
  
接收参数<span class="token operator">:</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>query<span class="token punctuation">.</span>id
</code></pre></div><p>params方式传参和接收参数</p> <div class="language-js extra-class"><pre class="language-js"><code>传参<span class="token operator">:</span> 
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        name<span class="token operator">:</span><span class="token string">'xxx'</span><span class="token punctuation">,</span>
        params<span class="token operator">:</span><span class="token punctuation">{</span>
          id<span class="token operator">:</span>id
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
  
接收参数<span class="token operator">:</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id
</code></pre></div><blockquote><p>params传参，push里面只能是 name:'xxxx',不能是path:'/xxx',因为params只能用name来引入路由，如果这里写成了path，接收参数页面会是undefined！！！
query 和 params 传参方式的区别</p></blockquote> <ul><li>query 地址栏显示参数，params 则不会，</li> <li>params只能用name来引入路由，query用name，path都可以</li> <li>params参数要在路由中声明了才不会消失。</li></ul> <p>详细：<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noopener noreferrer">导航守卫<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://segmentfault.com/a/1190000012735168#comment-area" target="_blank" rel="noopener noreferrer">query 和 params<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="route-和-router-的区别？"><a href="#route-和-router-的区别？" class="header-anchor">#</a> $route 和 $router 的区别？</h2> <p>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。</p> <p>而 $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</p> <h2 id="组件渲染和更新过程"><a href="#组件渲染和更新过程" class="header-anchor">#</a> 组件渲染和更新过程</h2> <p>渲染组件时，会通过 Vue.extend 方法构建子组件的构造函数，并进行实例化。最终手动调用 $mount() 进行挂载，更新组件时会 进行 patchVnode 流程，核心是 diff 算法。</p> <h2 id="provide-inject-使用"><a href="#provide-inject-使用" class="header-anchor">#</a> provide / inject 使用</h2> <div class="language-! extra-class"><pre class="language-text"><code>provide 和 inject 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。
</code></pre></div><p>这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//父级组件 a.vue</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;VmRadioGroup&quot;</span><span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">provide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      RadioGroup<span class="token operator">:</span> <span class="token keyword">this</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 子组件注入</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;VmRadio&quot;</span><span class="token punctuation">,</span>
  inject<span class="token operator">:</span> <span class="token punctuation">{</span>
    RadioGroup<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token keyword">default</span><span class="token operator">:</span>  <span class="token string">&quot;&quot;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="简单介绍-一下-vuex"><a href="#简单介绍-一下-vuex" class="header-anchor">#</a> 简单介绍 一下 Vuex</h2> <p>Vuex 是一个专门为 Vue 应用程序开发的状态管理工具，每一个 Vuex 应用的核心是 store。Vuex 主要应用了<strong>单例模式</strong>，这样不管我们尝试去创建多少次，它都只会返回第一次创建的哪一个唯一的实例。</p> <p>Vuex 主要包含一下几个模块：</p> <ul><li>State：定义应用状态的数据结构</li> <li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li> <li>Mutation：唯一更改 store 中状态的方法，且必须为同步</li> <li>Action：用于 (commit) mutation，可包含任意异步操作</li> <li>Module：可将单一 Store 拆分为多个 store 且保存在单一状态树中</li></ul> <h2 id="为什么-vuex-的-mutation-中不能做异步操作"><a href="#为什么-vuex-的-mutation-中不能做异步操作" class="header-anchor">#</a> 为什么 Vuex 的 mutation 中不能做异步操作</h2> <p>Vuex 中所有的状态更新的唯一途径都是通过 mutation，异步通过 Action 来提交 mutation实现，这样可以使我们方便地追踪每一个状态的变化。
如果 mutation 支持异步操作，那么就没有办法知道状态何时更新，，不能很好地追踪状态的变化，也给我们的调试带来困难。</p> <!----></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">9/11/2020, 3:18:55 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Vimalate/blog/VUE-Library/vue响应原理.html" class="prev">
        vue响应原理
      </a></span> <span class="next"><a href="/Vimalate/blog/VUE-Library/vue项目问题总结.html">
        vue项目问题总结
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/Vimalate/assets/js/app.d87d40d0.js" defer></script><script src="/Vimalate/assets/js/2.302ef7ec.js" defer></script><script src="/Vimalate/assets/js/126.edd01363.js" defer></script><script src="/Vimalate/assets/js/3.89fcb6a6.js" defer></script>
  </body>
</html>
